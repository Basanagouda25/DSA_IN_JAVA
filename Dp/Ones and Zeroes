class Solution {
    private int[][][] dp;
    private int solve(int[][] count,int m,int n,int i){
        if(i >= count.length || (m==0 && n==0))
            return 0;
        if(dp[m][n][i] != -1)
            return dp[m][n][i];
        int take = 0;
        if(count[i][0] <= m && count[i][1] <= n){
            take = 1 + solve(count, m-count[i][0],n-count[i][1],i+1);
        }
        int skip = solve(count,m,n,i+1);
        return dp[m][n][i] = Math.max(take,skip);
    }




    public int findMaxForm(String[] strs, int m, int n) {
        int l = strs.length;
        int[][] count = new int[l][2]; //only for 0 & 1 so 2

        for(int i=0; i<l; i++){
            int zeros = 0,ones = 0;
            for(char c:strs[i].toCharArray()){
                if(c == '0')
                    zeros++;
                else
                    ones++;
            }
            count[i][0] = zeros;
            count[i][1] = ones;
        }
        dp = new int[m+1][n+1][l];
        for(int i=0; i<=m; i++){
            for(int j=0; j<=n; j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        return solve(count,m,n,0);
    } 
}
